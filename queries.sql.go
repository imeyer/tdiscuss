// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package main

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrReturnID = `-- name: CreateOrReturnID :one
SELECT id::bigint, is_admin::boolean FROM createOrReturnID($1)
`

type CreateOrReturnIDRow struct {
	ID      int64
	IsAdmin bool
}

func (q *Queries) CreateOrReturnID(ctx context.Context, pEmail string) (CreateOrReturnIDRow, error) {
	row := q.db.QueryRow(ctx, createOrReturnID, pEmail)
	var i CreateOrReturnIDRow
	err := row.Scan(&i.ID, &i.IsAdmin)
	return i, err
}

const createThread = `-- name: CreateThread :exec
INSERT INTO thread (subject,member_id,last_member_id) VALUES ($1,$2,$3)
`

type CreateThreadParams struct {
	Subject      string
	MemberID     int64
	LastMemberID int64
}

func (q *Queries) CreateThread(ctx context.Context, arg CreateThreadParams) error {
	_, err := q.db.Exec(ctx, createThread, arg.Subject, arg.MemberID, arg.LastMemberID)
	return err
}

const createThreadPost = `-- name: CreateThreadPost :exec
INSERT INTO
  thread_post
    (thread_id,body,member_id)
  VALUES
    ($1,$2,$3)
`

type CreateThreadPostParams struct {
	ThreadID int64
	Body     pgtype.Text
	MemberID int64
}

func (q *Queries) CreateThreadPost(ctx context.Context, arg CreateThreadPostParams) error {
	_, err := q.db.Exec(ctx, createThreadPost, arg.ThreadID, arg.Body, arg.MemberID)
	return err
}

const getBoardData = `-- name: GetBoardData :one
SELECT
  id,
  title,
  total_members,
  total_threads,
  total_thread_posts,
  edit_window
FROM board_data
`

type GetBoardDataRow struct {
	ID               int32
	Title            string
	TotalMembers     pgtype.Int4
	TotalThreads     pgtype.Int4
	TotalThreadPosts pgtype.Int4
	EditWindow       pgtype.Int4
}

func (q *Queries) GetBoardData(ctx context.Context) (GetBoardDataRow, error) {
	row := q.db.QueryRow(ctx, getBoardData)
	var i GetBoardDataRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.TotalMembers,
		&i.TotalThreads,
		&i.TotalThreadPosts,
		&i.EditWindow,
	)
	return i, err
}

const getMember = `-- name: GetMember :one
SELECT
  m.email,
  mp.location,
  m.id,
  mp.bio,
  mp.timezone,
  mp.preferred_name,
  mp.proper_name,
  mp.pronouns,
  m.date_joined,
  mp.photo_url
FROM
  member m
LEFT JOIN
  member_profile mp
ON
  m.id = mp.member_id
WHERE
  m.id = $1
`

type GetMemberRow struct {
	Email         string
	Location      pgtype.Text
	ID            int64
	Bio           pgtype.Text
	Timezone      pgtype.Text
	PreferredName pgtype.Text
	ProperName    pgtype.Text
	Pronouns      pgtype.Text
	DateJoined    pgtype.Timestamptz
	PhotoUrl      pgtype.Text
}

func (q *Queries) GetMember(ctx context.Context, id int64) (GetMemberRow, error) {
	row := q.db.QueryRow(ctx, getMember, id)
	var i GetMemberRow
	err := row.Scan(
		&i.Email,
		&i.Location,
		&i.ID,
		&i.Bio,
		&i.Timezone,
		&i.PreferredName,
		&i.ProperName,
		&i.Pronouns,
		&i.DateJoined,
		&i.PhotoUrl,
	)
	return i, err
}

const getMemberId = `-- name: GetMemberId :one
SELECT id FROM member WHERE email = $1
`

func (q *Queries) GetMemberId(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, getMemberId, email)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getThreadForEdit = `-- name: GetThreadForEdit :one
SELECT m.email AS email,
  t.id AS thread_id,
  t.subject AS subject,
  tp.id AS thread_post_id,
  tp.body AS body
FROM thread t
LEFT JOIN thread_post tp
  ON tp.thread_id=t.id
LEFT JOIN member m
  ON t.member_id=m.id
WHERE t.id=$1 AND m.id=$2
`

type GetThreadForEditParams struct {
	ID   int64
	ID_2 int64
}

type GetThreadForEditRow struct {
	Email        pgtype.Text
	ThreadID     int64
	Subject      string
	ThreadPostID pgtype.Int8
	Body         pgtype.Text
}

func (q *Queries) GetThreadForEdit(ctx context.Context, arg GetThreadForEditParams) (GetThreadForEditRow, error) {
	row := q.db.QueryRow(ctx, getThreadForEdit, arg.ID, arg.ID_2)
	var i GetThreadForEditRow
	err := row.Scan(
		&i.Email,
		&i.ThreadID,
		&i.Subject,
		&i.ThreadPostID,
		&i.Body,
	)
	return i, err
}

const getThreadPostForEdit = `-- name: GetThreadPostForEdit :one
SELECT tp.id, tp.body
FROM thread_post tp LEFT JOIN member m
  ON tp.member_id=m.id
WHERE tp.id=$1 AND m.id=$2
`

type GetThreadPostForEditParams struct {
	ID   int64
	ID_2 int64
}

type GetThreadPostForEditRow struct {
	ID   int64
	Body pgtype.Text
}

func (q *Queries) GetThreadPostForEdit(ctx context.Context, arg GetThreadPostForEditParams) (GetThreadPostForEditRow, error) {
	row := q.db.QueryRow(ctx, getThreadPostForEdit, arg.ID, arg.ID_2)
	var i GetThreadPostForEditRow
	err := row.Scan(&i.ID, &i.Body)
	return i, err
}

const getThreadPostSequenceId = `-- name: GetThreadPostSequenceId :one
SELECT currval('thread_id_post_seq')
`

func (q *Queries) GetThreadPostSequenceId(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getThreadPostSequenceId)
	var currval int64
	err := row.Scan(&currval)
	return currval, err
}

const getThreadSequenceId = `-- name: GetThreadSequenceId :one
SELECT currval('thread_id_seq')
`

func (q *Queries) GetThreadSequenceId(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getThreadSequenceId)
	var currval int64
	err := row.Scan(&currval)
	return currval, err
}

const getThreadSubjectById = `-- name: GetThreadSubjectById :one
SELECT subject FROM thread WHERE id=$1
`

func (q *Queries) GetThreadSubjectById(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRow(ctx, getThreadSubjectById, id)
	var subject string
	err := row.Scan(&subject)
	return subject, err
}

const listMemberThreads = `-- name: ListMemberThreads :many
SELECT
  t.id as thread_id,
  t.date_last_posted,
  m.id,
  m.email,
  l.id as lastid,
  l.email as lastname,
  t.subject,
  t.posts,
  t.views,
  (CASE WHEN tm.last_view_posts IS null THEN 0 ELSE tm.last_view_posts END) as last_view_posts,
  (CASE WHEN tm.date_posted IS NOT null AND tm.undot IS false AND tm.member_id IS NOT null THEN 't' ELSE 'f' END)::boolean as dot,
  t.sticky,
  t.locked
FROM
  thread t
LEFT JOIN
  member m
ON
  m.id=t.member_id
LEFT JOIN
  member l
ON
  l.id=t.last_member_id
LEFT JOIN
  thread_post tp
ON
  tp.id=t.first_post_id
LEFT OUTER JOIN
  thread_member tm
ON
  (tm.member_id=$1 AND tm.thread_id=t.id)
WHERE t.sticky IS false
AND m.id=$1
ORDER BY t.date_last_posted DESC
LIMIT 10
`

type ListMemberThreadsRow struct {
	ThreadID       int64
	DateLastPosted pgtype.Timestamptz
	ID             pgtype.Int8
	Email          pgtype.Text
	Lastid         pgtype.Int8
	Lastname       pgtype.Text
	Subject        string
	Posts          pgtype.Int4
	Views          pgtype.Int4
	LastViewPosts  interface{}
	Dot            bool
	Sticky         pgtype.Bool
	Locked         pgtype.Bool
}

func (q *Queries) ListMemberThreads(ctx context.Context, memberID int64) ([]ListMemberThreadsRow, error) {
	rows, err := q.db.Query(ctx, listMemberThreads, memberID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMemberThreadsRow
	for rows.Next() {
		var i ListMemberThreadsRow
		if err := rows.Scan(
			&i.ThreadID,
			&i.DateLastPosted,
			&i.ID,
			&i.Email,
			&i.Lastid,
			&i.Lastname,
			&i.Subject,
			&i.Posts,
			&i.Views,
			&i.LastViewPosts,
			&i.Dot,
			&i.Sticky,
			&i.Locked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listThreadPosts = `-- name: ListThreadPosts :many
SELECT
  tp.id,
  tp.date_posted,
  m.id as member_id,
  m.email,
  tp.body,
  t.subject,
  t.id as thread_id,
  m.is_admin,
  (CASE WHEN (m.email = $2 AND t.date_posted >= NOW() - INTERVAL '900 seconds') THEN 't' ELSE 'f' END)::boolean as can_edit
FROM
  thread_post tp
LEFT JOIN
  member m
ON
  m.id=tp.member_id
LEFT JOIN
  thread t
ON
  t.id = tp.thread_id
WHERE tp.thread_id=$1
ORDER BY tp.date_posted ASC
`

type ListThreadPostsParams struct {
	ThreadID int64
	Email    string
}

type ListThreadPostsRow struct {
	ID         int64
	DatePosted pgtype.Timestamptz
	MemberID   pgtype.Int8
	Email      pgtype.Text
	Body       pgtype.Text
	Subject    pgtype.Text
	ThreadID   pgtype.Int8
	IsAdmin    pgtype.Bool
	CanEdit    bool
}

func (q *Queries) ListThreadPosts(ctx context.Context, arg ListThreadPostsParams) ([]ListThreadPostsRow, error) {
	rows, err := q.db.Query(ctx, listThreadPosts, arg.ThreadID, arg.Email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListThreadPostsRow
	for rows.Next() {
		var i ListThreadPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.DatePosted,
			&i.MemberID,
			&i.Email,
			&i.Body,
			&i.Subject,
			&i.ThreadID,
			&i.IsAdmin,
			&i.CanEdit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listThreads = `-- name: ListThreads :many
SELECT
  t.id as thread_id,
  t.date_last_posted,
  m.id,
  m.email,
  l.id as lastid,
  l.email as lastname,
  t.subject,
  t.posts,
  t.views,
  tp.body,
  (CASE WHEN (m.email = $1 AND t.date_posted >= NOW() - INTERVAL '900 seconds') THEN 't' ELSE 'f' END)::boolean as can_edit,
  (CASE WHEN tm.last_view_posts IS null THEN 0 ELSE tm.last_view_posts END) as last_view_posts,
  (CASE WHEN tm.date_posted IS NOT null AND tm.undot IS false AND tm.member_id IS NOT null THEN 't' ELSE 'f' END)::boolean as dot,
  t.sticky,
  t.locked
FROM
  thread t
LEFT JOIN
  member m
ON
  m.id=t.member_id
LEFT JOIN
  member l
ON
  l.id=t.last_member_id
LEFT JOIN
  thread_post tp
ON
  tp.id=t.first_post_id
LEFT OUTER JOIN
  thread_member tm
ON
  (tm.member_id=$2 AND tm.thread_id=t.id)
WHERE t.sticky IS false
ORDER BY t.date_last_posted DESC
LIMIT 100
`

type ListThreadsParams struct {
	Email    string
	MemberID int64
}

type ListThreadsRow struct {
	ThreadID       int64
	DateLastPosted pgtype.Timestamptz
	ID             pgtype.Int8
	Email          pgtype.Text
	Lastid         pgtype.Int8
	Lastname       pgtype.Text
	Subject        string
	Posts          pgtype.Int4
	Views          pgtype.Int4
	Body           pgtype.Text
	CanEdit        bool
	LastViewPosts  interface{}
	Dot            bool
	Sticky         pgtype.Bool
	Locked         pgtype.Bool
}

func (q *Queries) ListThreads(ctx context.Context, arg ListThreadsParams) ([]ListThreadsRow, error) {
	rows, err := q.db.Query(ctx, listThreads, arg.Email, arg.MemberID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListThreadsRow
	for rows.Next() {
		var i ListThreadsRow
		if err := rows.Scan(
			&i.ThreadID,
			&i.DateLastPosted,
			&i.ID,
			&i.Email,
			&i.Lastid,
			&i.Lastname,
			&i.Subject,
			&i.Posts,
			&i.Views,
			&i.Body,
			&i.CanEdit,
			&i.LastViewPosts,
			&i.Dot,
			&i.Sticky,
			&i.Locked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBoardEditWindow = `-- name: UpdateBoardEditWindow :exec
UPDATE board_data
SET edit_window=$1
`

func (q *Queries) UpdateBoardEditWindow(ctx context.Context, editWindow pgtype.Int4) error {
	_, err := q.db.Exec(ctx, updateBoardEditWindow, editWindow)
	return err
}

const updateBoardTitle = `-- name: UpdateBoardTitle :exec
UPDATE board_data
SET title=$1
`

func (q *Queries) UpdateBoardTitle(ctx context.Context, title string) error {
	_, err := q.db.Exec(ctx, updateBoardTitle, title)
	return err
}

const updateMemberProfileByID = `-- name: UpdateMemberProfileByID :exec
UPDATE member_profile SET
  photo_url = $2,
  location = $3,
  bio = $4,
  timezone = $5,
  preferred_name = $6,
  pronouns = $7
WHERE member_id = $1
`

type UpdateMemberProfileByIDParams struct {
	MemberID      int64
	PhotoUrl      pgtype.Text
	Location      pgtype.Text
	Bio           pgtype.Text
	Timezone      pgtype.Text
	PreferredName pgtype.Text
	Pronouns      pgtype.Text
}

func (q *Queries) UpdateMemberProfileByID(ctx context.Context, arg UpdateMemberProfileByIDParams) error {
	_, err := q.db.Exec(ctx, updateMemberProfileByID,
		arg.MemberID,
		arg.PhotoUrl,
		arg.Location,
		arg.Bio,
		arg.Timezone,
		arg.PreferredName,
		arg.Pronouns,
	)
	return err
}

const updateThread = `-- name: UpdateThread :exec
UPDATE thread SET
  subject = $1
WHERE id = $2
  AND member_id = $3
  AND date_posted >= NOW() - INTERVAL '900 seconds'
`

type UpdateThreadParams struct {
	Subject  string
	ID       int64
	MemberID int64
}

func (q *Queries) UpdateThread(ctx context.Context, arg UpdateThreadParams) error {
	_, err := q.db.Exec(ctx, updateThread, arg.Subject, arg.ID, arg.MemberID)
	return err
}

const updateThreadPost = `-- name: UpdateThreadPost :exec
UPDATE thread_post SET
  body = $1
WHERE id = $2
  AND member_id = $3
  AND date_posted >= NOW() - INTERVAL '900 seconds'
`

type UpdateThreadPostParams struct {
	Body     pgtype.Text
	ID       int64
	MemberID int64
}

func (q *Queries) UpdateThreadPost(ctx context.Context, arg UpdateThreadPostParams) error {
	_, err := q.db.Exec(ctx, updateThreadPost, arg.Body, arg.ID, arg.MemberID)
	return err
}
